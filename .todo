# TODO

## ROADMAP

### I/
- [x] 1. Language features
- [x] 2. Types
- 3. Optimization
### II/
- 4. Add backend for x86_64 intel
    - emitter/code_intel.cpp
        - https://imada.sdu.dk/u/kslarsen/dm546/Material/IntelnATT.htm
    - fasm
        https://flatassembler.net/
- 5. Add syscalls + small std lib to support test cases
    - impl syscalls in asm
    - link asm syscalls
        - writing C software without the standard library:
            https://gist.github.com/tcoppex/443d1dd45f873d96260195d6431b0989
            - ex asm syscall
            - ex strlen, puts
    - malloc in c:
        - https://github.com/RAGUL1902/Dynamic-Memory-Allocation-in-C
### III/
- 6. Add frontend for my-lang
    - parser/lexer.cpp
    - parser/parser.cpp
    - test/tests/
- 7. Implement preprocessor
    - see cython prebuild
- 8. Implement more standard library

## BACKLOG

---- Notes

---- Bug fixes

---- Features

---- Performance

- replace string + with += where it is easy and makes sense
(do not spend to much time on this optim, as the runtime is 70% regex)

---- Part 3 Optimization

- use bitmask for cmd line params

---- Readme

- add limits of compiler in readme:
    - no memory overflow check, max memory allocation is (2^63)-1 bits (function stack, aggregate type)
    - same for memory addresses / pointer values
        -> overflow = undefined behavior

## PERFORMANCE

Not needed, the bottleneck is by far the regex tokenizer.
- Set capacity of containers (vector, unordered map, string) with reserve() when size is known, or if good upper estimate.
- Construct line in emitter with += operator instead of +, because it is 3x cheaper (but less readable).

## PREPROC INCLUDES

- in args, pass all included directories (PARSE_INCLUDE_ARGS(X))
- create include context that contains:
    - vector of max FOPEN_MAX file buffers
      + for each, util file_in, buffer, l
- during lexing, start with main src and traverse all files in order of includes
- when hit include, open buffer and pop it on the vector (set file_in, buffer, l), then lex it
- then pop it and go back to previous file (set back file_in, buffer, l to previous)
- keep a list of previously traversed files to ignore if a file is hit more than once
- increment total amount of line read and pass it to the ast (size_t line)
- keep track in a map of which file is read between which start and end lines
- during runtime error, use the map and the absolute line count to find back the relative line and file
    - with errors::handle_error_at_line
- if the amount of buffers open >= FOPEN_MAX, close the furthest open buffer from current
    - when back to a closed buffer, reopen it and traverse it to the previous location to continue lex
- for example:
    file 1 (l: 0-42) * still open
    file 2 (l: 43-65) (22 lines)
    file 1 (l: 66-100) * still open
    file 3 (l: 101-126) * still open
    file 4 (l: 126-157) (31 lines)
    file 5 (l: 158-170) (12 lines)
    file 3 (l: 171-209) (25 + 38 = 63 lines)
    file 1 (l: 210-256) (42 + 34 + 46 = 122 lines)

## Grammar ideas

https://www.reddit.com/r/C_Programming/comments/xt6n5t/what_is_something_you_would_have_changed_about/

pub fn add:: x: uint32, y: uint32 -> uint32 = {
    if x eq 0: (
        # do domething
    )
    else if x gt 2: ( 
        # do domething
    )
    else: (
        # do domething
    )
}

or ? 

pub fn add:: x: uint32, y: uint32 -> uint32 = {
    if x eq 0:
        # do domething
        end
    else if x gt 2: 
        # do domething
        end
    else:
        # do domething
        end
    :
    #:
        empty comment
    end#
    end
}

for let x: uint32 <- 0; x lt 50; x += 1: (
    let res: uint32 <- fn(2, 3);
    
)

function is 
extern -> extern fn
no specifier -> pub fn
static -> fn

variable is
extern -> extern var
no specifier -> let
static -> var (or static var)

ternary -> ... then ... else ...

do {} while(); ->
dowhile ...:
    ...
    end

void -> ()

pub fn main:: ()-> (): (
)

@ instead of &
^ instead of *

&& and
|| or
== eq
!= ne
<= ge
>= le
! not
< lt
> gt

{
}
   only for declaration
   scope is :
            end

